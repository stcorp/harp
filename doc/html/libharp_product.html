<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Product &mdash; HARP 1.26 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="next" title="Product Metadata" href="libharp_product_metadata.html" />
    <link rel="prev" title="Geometry" href="libharp_geometry.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            HARP
          </a>
              <div class="version">
                1.26
              </div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="conventions/index.html">Conventions</a></li>
<li class="toctree-l1"><a class="reference internal" href="algorithms/index.html">Algorithms</a></li>
<li class="toctree-l1"><a class="reference internal" href="operations.html">Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="ingestions/index.html">Ingestion definitions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="libharp.html">C library</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="libharp.html#introduction">Introduction</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="libharp.html#modules">Modules</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="libharp_collocation.html">Collocation</a></li>
<li class="toctree-l3"><a class="reference internal" href="libharp_dataset.html">Dataset</a></li>
<li class="toctree-l3"><a class="reference internal" href="libharp_documentation.html">Documentation</a></li>
<li class="toctree-l3"><a class="reference internal" href="libharp_error.html">Error</a></li>
<li class="toctree-l3"><a class="reference internal" href="libharp_general.html">General</a></li>
<li class="toctree-l3"><a class="reference internal" href="libharp_geometry.html">Geometry</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">Product</a></li>
<li class="toctree-l3"><a class="reference internal" href="libharp_product_metadata.html">Product Metadata</a></li>
<li class="toctree-l3"><a class="reference internal" href="libharp_variable.html">Variable</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="idl.html">IDL interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="matlab.html">MATLAB interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="python.html">Python interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="R.html">R interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="tools.html">Command line tools</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">HARP</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="libharp.html">C library</a></li>
      <li class="breadcrumb-item active">Product</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="product">
<h1>Product</h1>
<dl>
<dt class="sig sig-object cpp">
<span class="target" id="group__harp__product"></span><em><span class="pre">group</span></em> <span class="sig-name descname"><span class="pre">harp_product</span></span></dt>
<dd><p>The HARP Products module contains everything related to HARP products.</p>
<p>The representation of a HARP product in C is a structure containing:<ul class="simple">
<li><p>an array of variables</p></li>
<li><p>an array of dimension lengths for each dimension type (unavailable dimensions have length -1)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">source_product</span></code> global attribute (can be NULL)</p></li>
<li><p>the <code class="docutils literal notranslate"><span class="pre">history</span></code> global attribute (can be NULL)</p></li>
</ul>
</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">Conventions</span></code> global attribute is not included as this is automatically handled by the import/export functions of HARP. Similar, the <code class="docutils literal notranslate"><span class="pre">datetime_start</span></code> and <code class="docutils literal notranslate"><span class="pre">datetime_stop</span></code> attributes are handled by the export function. They are set to the minimum and maximum values of the variables <code class="docutils literal notranslate"><span class="pre">datetime</span></code>, <code class="docutils literal notranslate"><span class="pre">datetime_start</span></code> and <code class="docutils literal notranslate"><span class="pre">datetime_stop</span></code> (if available).</p>
<p>For each variable in the HARP product the dimensions need to match the length of their type as defined in the dimension array of the HARP product (for all dimension types except ‘independent’).</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-typedefs">Typedefs</p>
<dl class="cpp type">
<dt class="sig sig-object cpp" id="_CPPv412harp_product">
<span id="_CPPv312harp_product"></span><span id="_CPPv212harp_product"></span><span id="harp_product"></span><span class="target" id="group__harp__product_1gab3fddebd8b746e0d76948d03ca073ddc"></span><span class="k"><span class="pre">typedef</span></span><span class="w"> </span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv419harp_product_struct" title="harp_product_struct"><span class="n"><span class="pre">harp_product_struct</span></span></a><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product</span></span></span><br /></dt>
<dd><p>HARP Product typedef </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-functions">Functions</p>
<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424harp_product_bin_spatialP12harp_productllPllPdlPd">
<span id="_CPPv324harp_product_bin_spatialP12harp_productllPllPdlPd"></span><span id="_CPPv224harp_product_bin_spatialP12harp_productllPllPdlPd"></span><span id="harp_product_bin_spatial__harp_productP.l.l.lP.l.doubleP.l.doubleP"></span><span class="target" id="group__harp__product_1ga10e515f7b5a798c0b952db718bafeaa3"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_bin_spatial</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_time_bins</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_time_elements</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">time_bin_index</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_latitude_edges</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">latitude_edges</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_longitude_edges</span></span>, <span class="kt"><span class="pre">double</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">longitude_edges</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Bin the product’s variables into a spatial grid. This will bin all variables with a time dimension into a three dimensional time x latitude x longitude grid. Each time sample will first be allocated to a time bin defined by time_bin_index (similar to <em>harp_product_bin</em>). Then within that time bin the sample will be allocated to the appropriate cell(s) in the latitude/longitude grid as defined by the latitude_edges and longitude_edges variables.</p>
<p>The lat/lon grid will be a fixed time-independent grid and will have ‘num_latitude_edges-1’ latitudes and ‘num_longitude_edges-1’ longitudes. The latitude_edges and longitude_edges arrays provide the boundaries of the grid cells in degrees and need to be provided in a strict ascending order. The latitude edge values need to be between -90 and 90 and for the longitude edge values the constraint is that the difference between the last and first edge should be &lt;= 360.</p>
<p>If the product has latitude_bounds {time,independent} and longitude_bounds {time,independent} variables then an area binning is performed. This means that each sample will be allocated to each lat/lon grid cell based on the amount of overlap. This overlap calculation will treat lines between points as straight lines within the carthesian plane (i.e. using a Plate Carree projection, and not using great circle arcs between points on a sphere).</p>
<p>If the product doesn’t have lat/lon bounds per sample, it should have latitude {time} and longitude {time} variables. The binning onto the lat/lon grid will then be a point binning. This means that each sample is allocated to only one grid cell based on its lat/lon coordinate. To achieve a unique assignment, for each cell the lower edge will be considered inclusive and the upper edge exclusive (except for the last cell (when there is no wrap-around)).</p>
<p>The resulting value for each time/lat/lon cell will be the average of all values for that cell. This will be a weighted average in case an area binning is performed and a straight average for point binning. Variables with multiple dimensions will have all elements in its sub dimensions averaged on an element by element basis (i.e. sub dimensions will be retained).</p>
<p>Variables that have a time dimension but no unit (or using a string data type) will be removed. Any existing count or weight variables will also be removed.</p>
<p>For uncertainty variables the first order propagation rules are used (assuming full correlation).</p>
<p>All variables that are binned are converted to a double data type. Cells that have no samples will end up with a NaN value.</p>
<p>A ‘count’ variable will be added to the product that will contain the number of samples per time bin. In addition, a ‘weight’ variable will be added that will contain the sum of weights for the contribution to each cell. If a variable contained NaN values then a variable specific weight variable will be created with only the sum of weights for the non-NaN entries.</p>
<p>For angle variables a variable-specific weight variable will be created that contains the magnitude of the sum of the unit vectors that was used to calculate the angle average.</p>
<p>Axis variables for the time dimension such as datetime, datetime_length, datetime_start, and datetime_stop will only be binned in the time dimension (and will not gain a latitude or longitude dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to regrid. </p></li>
<li><p><strong>num_time_bins</strong> – Number of target bins in the time dimension. </p></li>
<li><p><strong>num_time_elements</strong> – Length of bin_index array (should equal the length of the time dimension) </p></li>
<li><p><strong>time_bin_index</strong> – Array of target time bin index numbers (0 .. num_bins-1) for each sample in the time dimension. </p></li>
<li><p><strong>num_latitude_edges</strong> – Number of edges for the latitude grid (number of latitude rows = num_latitude_edges - 1) </p></li>
<li><p><strong>latitude_edges</strong> – latitude grid edge vales </p></li>
<li><p><strong>num_longitude_edges</strong> – Number of edges for the longitude grid (number of longitude columns = num_longitude_edges - 1) </p></li>
<li><p><strong>longitude_edges</strong> – longitude grid edge vales</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416harp_product_binP12harp_productllPl">
<span id="_CPPv316harp_product_binP12harp_productllPl"></span><span id="_CPPv216harp_product_binP12harp_productllPl"></span><span id="harp_product_bin__harp_productP.l.l.lP"></span><span class="target" id="group__harp__product_1gac1a935b414c03ed0a9a414a53dbc311e"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_bin</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_bins</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_elements</span></span>, <span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">bin_index</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Bin the product’s variables. This will bin all variables in the time dimension. Each time sample will be put in the bin defined by bin_index. All variables with a time dimension will then be resampled using these bins. The resulting value for each variable will be the average of all values for the bin (using existing count or weight variables as weighting factors where available). Variables with multiple dimensions will have all elements in the sub dimensions averaged on an element by element basis.</p>
<p>Variables that have a time dimension but no unit (or using a string data type) will be removed. The exception are count and weight variables, which will be summed.</p>
<p>All variables that are binned (except existing count/weight variables) are converted to a double data type. Bins that have no samples will end up with a NaN value.</p>
<p>If the product did not already have a ‘count’ variable then a ‘count’ variable will be added to the product that will contain the number of samples per bin.</p>
<p>Only non-NaN values will contribute to a bin. If there are NaN values and there is not already a variable-specific count or weight variable for that variable, then a separate variable-specific count variable will be created that will contain the number of non-NaN values that contributed to each bin. This count variable will have the same dimensions as the variable it provides the count for.</p>
<p>For angle variables a variable-specific weight variable will be created (if it did not yet exist) that contains the magnitude of the sum of the unit vectors that was used to calculate the angle average.</p>
<p>For uncertainty variables the first order propagation rules are used (assuming full correlation for systematic uncertainty variables and using the <a class="reference internal" href="libharp_general.html#group__harp__general_1ga9fea5f821a70646daeb1915bf2ae3ddb"><span class="std std-ref">harp_get_option_propagate_uncertainty()</span></a> setting for total and random uncertainty variables).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to regrid. </p></li>
<li><p><strong>num_bins</strong> – Number of target bins. </p></li>
<li><p><strong>num_elements</strong> – Length of bin_index array (should equal the length of the time dimension) </p></li>
<li><p><strong>bin_index</strong> – Array of target bin index numbers (0 .. num_bins-1) for each sample in the time dimension.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv433harp_product_get_derived_variablePK12harp_productPKcPK14harp_data_typePKciPK19harp_dimension_typePP13harp_variable">
<span id="_CPPv333harp_product_get_derived_variablePK12harp_productPKcPK14harp_data_typePKciPK19harp_dimension_typePP13harp_variable"></span><span id="_CPPv233harp_product_get_derived_variablePK12harp_productPKcPK14harp_data_typePKciPK19harp_dimension_typePP13harp_variable"></span><span id="harp_product_get_derived_variable__harp_productCP.cCP.harp_data_typeCP.cCP.i.harp_dimension_typeCP.harp_variablePP"></span><span class="target" id="group__harp__product_1gaa5bdb44215a418514463022ca2672c66"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_get_derived_variable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="libharp_general.html#_CPPv414harp_data_type" title="harp_data_type"><span class="n"><span class="pre">harp_data_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">data_type</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">unit</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_dimensions</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="libharp_general.html#_CPPv419harp_dimension_type" title="harp_dimension_type"><span class="n"><span class="pre">harp_dimension_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dimension_type</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Retrieve a new variable based on the set of automatic conversions that are supported by HARP.</p>
<p>If the product already contained a variable with the given name, you will get a copy of that variable (and converted to the specified data type and unit). Otherwise the function will try to create a new variable based on the data found in the product or on available auxiliary data (e.g. built-in climatology). The caller of this function will be responsible for the memory management of the returned variable. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>setting unit to NULL returns a variable in the original unit </p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>pointers to axis variables are passed through unmodified. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product from which to derive the new variable. </p></li>
<li><p><strong>name</strong> – Name of the variable that should be created. </p></li>
<li><p><strong>data_type</strong> – Data type (optional) of the variable that should be created. </p></li>
<li><p><strong>unit</strong> – Unit (optional) of the variable that should be created. </p></li>
<li><p><strong>num_dimensions</strong> – Number of dimensions of the variable that should be created. </p></li>
<li><p><strong>dimension_type</strong> – Type of dimension for each of the dimensions of the variable that should be created. </p></li>
<li><p><strong>variable</strong> – Pointer to the C variable where the derived HARP variable will be stored. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv433harp_product_add_derived_variableP12harp_productPKcPK14harp_data_typePKciPK19harp_dimension_type">
<span id="_CPPv333harp_product_add_derived_variableP12harp_productPKcPK14harp_data_typePKciPK19harp_dimension_type"></span><span id="_CPPv233harp_product_add_derived_variableP12harp_productPKcPK14harp_data_typePKciPK19harp_dimension_type"></span><span id="harp_product_add_derived_variable__harp_productP.cCP.harp_data_typeCP.cCP.i.harp_dimension_typeCP"></span><span class="target" id="group__harp__product_1gaa5caaf1e0e7f08afafbf91bc06428f96"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_add_derived_variable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="libharp_general.html#_CPPv414harp_data_type" title="harp_data_type"><span class="n"><span class="pre">harp_data_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">data_type</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">unit</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_dimensions</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="libharp_general.html#_CPPv419harp_dimension_type" title="harp_dimension_type"><span class="n"><span class="pre">harp_dimension_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dimension_type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Create a derived variable and add it to the product.</p>
<p>If a similar named variable with the right dimensions was already in the product then that variable will be modified to match the given unit (and in case <em>unit</em> is NULL, then the function will just leave the product unmodified). Otherwise the function will call <a class="reference internal" href="#group__harp__product_1gaa5bdb44215a418514463022ca2672c66"><span class="std std-ref">harp_product_get_derived_variable()</span></a> and add the new variable using <a class="reference internal" href="#group__harp__product_1ga84a2e8737ef00ab3ec8cecb54bd53d51"><span class="std std-ref">harp_product_add_variable()</span></a> (removing any existing variable with the same name, but different dimensions) </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product from which to derive the new variable and into which the derived variable should be placed. </p></li>
<li><p><strong>name</strong> – Name of the variable that should be added. </p></li>
<li><p><strong>data_type</strong> – Data type (optional) of the variable that should be added. </p></li>
<li><p><strong>unit</strong> – Unit (optional) of the variable that should be added. </p></li>
<li><p><strong>num_dimensions</strong> – Number of dimensions of the variable that should be created. </p></li>
<li><p><strong>dimension_type</strong> – Type of dimension for each of the dimensions of the variable that should be created. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416harp_product_newPP12harp_product">
<span id="_CPPv316harp_product_newPP12harp_product"></span><span id="_CPPv216harp_product_newPP12harp_product"></span><span id="harp_product_new__harp_productPP"></span><span class="target" id="group__harp__product_1ga0d4b0729140d78db3441be1b66451e91"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_new</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">new_product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Create new product. The product will be initialized with 0 variables and 0 attributes. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>new_product</strong> – Pointer to the C variable where the new HARP product will be stored. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419harp_product_deleteP12harp_product">
<span id="_CPPv319harp_product_deleteP12harp_product"></span><span id="_CPPv219harp_product_deleteP12harp_product"></span><span id="harp_product_delete__harp_productP"></span><span class="target" id="group__harp__product_1ga733c9e35d18dd76b7f9d7bf36c1c53a8"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_delete</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Delete product. Remove product and all attached variables and attributes. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>product</strong> – HARP product. </p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417harp_product_copyPK12harp_productPP12harp_product">
<span id="_CPPv317harp_product_copyPK12harp_productPP12harp_product"></span><span id="_CPPv217harp_product_copyPK12harp_productPP12harp_product"></span><span id="harp_product_copy__harp_productCP.harp_productPP"></span><span class="target" id="group__harp__product_1gaeb2e6f3916f21319e8c8576efaa1e351"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_copy</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">other_product</span></span>, <a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">new_product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Create a copy of a product. The function will create a deep-copy of the given product, also creating copyies of all attributes and variables. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other_product</strong> – Product that should be copied. </p></li>
<li><p><strong>new_product</strong> – Pointer to the variable where the new HARP product will be stored. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419harp_product_appendP12harp_productP12harp_product">
<span id="_CPPv319harp_product_appendP12harp_productP12harp_product"></span><span id="_CPPv219harp_product_appendP12harp_productP12harp_product"></span><span id="harp_product_append__harp_productP.harp_productP"></span><span class="target" id="group__harp__product_1gac38975a39f20971cac1cefb8416b2347"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_append</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">other_product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Append one product to another. The ‘index’ variable, if present, will be removed. All variables in both products will have a ‘time’ dimension introduced as first dimension. Both products will have all non-time dimensions extended to the maximum of either product. Any ‘source_product’ attribute for the first product will be removed.</p>
<p>If you pass NULL for ‘other_product’, then ‘product’ will be updated as if it was the result of a merge (i.e. remove ‘index’, add ‘time’ dimension, and remove ‘source_product’ attribute). </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to which data should be appended. </p></li>
<li><p><strong>other_product</strong> – (optional) Product that should be appended. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431harp_product_set_source_productP12harp_productPKc">
<span id="_CPPv331harp_product_set_source_productP12harp_productPKc"></span><span id="_CPPv231harp_product_set_source_productP12harp_productPKc"></span><span id="harp_product_set_source_product__harp_productP.cCP"></span><span class="target" id="group__harp__product_1ga2788cc7c42cf9fe9b2f60ed3231e3589"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_set_source_product</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product_path</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the source product attribute of the specified product. Stores the base name of <em>product_path</em> as the value of the source product attribute of the specified product. The previous value (if any) will be freed. The base name of the product path is the filename of the product without any directory name components. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product for which to set the source product attribute. </p></li>
<li><p><strong>product_path</strong> – Relative or absolute path to the product or just the product filename (can be NULL). </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv424harp_product_set_historyP12harp_productPKc">
<span id="_CPPv324harp_product_set_historyP12harp_productPKc"></span><span id="_CPPv224harp_product_set_historyP12harp_productPKc"></span><span id="harp_product_set_history__harp_productP.cCP"></span><span class="target" id="group__harp__product_1ga7693ca9ca73d407973f93f4a3d27d3bf"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_set_history</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">history</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Set the history attribute of the specified product. Store a copy of <em>history</em> as the value of the history attribute of the specified product. The previous value (if any) will be freed. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product for which to set the history attribute. </p></li>
<li><p><strong>history</strong> – New value for the history attribute (can be NULL). </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425harp_product_add_variableP12harp_productP13harp_variable">
<span id="_CPPv325harp_product_add_variableP12harp_productP13harp_variable"></span><span id="_CPPv225harp_product_add_variableP12harp_productP13harp_variable"></span><span id="harp_product_add_variable__harp_productP.harp_variableP"></span><span class="target" id="group__harp__product_1ga84a2e8737ef00ab3ec8cecb54bd53d51"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_add_variable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Add a variable to a product. </p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The memory management of the variable will be handled via the product after you have added the variable. </p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to which the variable should be added. </p></li>
<li><p><strong>variable</strong> – Variable that should be added to the product. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428harp_product_detach_variableP12harp_productPK13harp_variable">
<span id="_CPPv328harp_product_detach_variableP12harp_productPK13harp_variable"></span><span id="_CPPv228harp_product_detach_variableP12harp_productPK13harp_variable"></span><span id="harp_product_detach_variable__harp_productP.harp_variableCP"></span><span class="target" id="group__harp__product_1ga99d5d7f3a1e70ee69ee7519aaf9e3be4"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_detach_variable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Detach a variable from a product. Removes a variable from a product without deleting the variable itself. After detaching, the caller of the function will be responsible for the further memory management of the variable. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product from which the variable should be detached. </p></li>
<li><p><strong>variable</strong> – Variable that should be detached. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428harp_product_remove_variableP12harp_productP13harp_variable">
<span id="_CPPv328harp_product_remove_variableP12harp_productP13harp_variable"></span><span id="_CPPv228harp_product_remove_variableP12harp_productP13harp_variable"></span><span id="harp_product_remove_variable__harp_productP.harp_variableP"></span><span class="target" id="group__harp__product_1ga88c38cc628718f06065e9160bf735057"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_remove_variable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Remove a variable from a product. This function removes the specified variable from the product and then deletes the variable itself. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product from which the variable should be removed. </p></li>
<li><p><strong>variable</strong> – Variable that should be removed. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv436harp_product_remove_variable_by_nameP12harp_productPKc">
<span id="_CPPv336harp_product_remove_variable_by_nameP12harp_productPKc"></span><span id="_CPPv236harp_product_remove_variable_by_nameP12harp_productPKc"></span><span id="harp_product_remove_variable_by_name__harp_productP.cCP"></span><span class="target" id="group__harp__product_1ga592399cec1ab4a611a620fc788a9c84d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_remove_variable_by_name</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Remove a variable from a product using the name of the variable. This function removes the variable with the specified name from the product and then deletes the variable itself. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product from which the variable should be removed. </p></li>
<li><p><strong>name</strong> – Name of the variable that should be removed. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv429harp_product_replace_variableP12harp_productP13harp_variable">
<span id="_CPPv329harp_product_replace_variableP12harp_productP13harp_variable"></span><span id="_CPPv229harp_product_replace_variableP12harp_productP13harp_variable"></span><span id="harp_product_replace_variable__harp_productP.harp_variableP"></span><span class="target" id="group__harp__product_1ga29283b1d2a2042fb164ade0b8b5be9e7"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_replace_variable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Replaces an existing variable with the one provided. The product should already contain a variable with the same name as <em>variable</em>. This function searches in the list of variables in the product for one with the same name, removes this variable and then adds the given <em>variable</em> in its place. Note that if you try to replace a variable with itself the function does nothing (and returns success). </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product in which the variable should be replaced. </p></li>
<li><p><strong>variable</strong> – Variable that should be used to replace an existing variable. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv425harp_product_has_variablePK12harp_productPKc">
<span id="_CPPv325harp_product_has_variablePK12harp_productPKc"></span><span id="_CPPv225harp_product_has_variablePK12harp_productPKc"></span><span id="harp_product_has_variable__harp_productCP.cCP"></span><span class="target" id="group__harp__product_1ga38ab016c406bcb69f3286b1285bf9f82"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_has_variable</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Test if product contains a variable with the specified name. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to search. </p></li>
<li><p><strong>name</strong> – Name of the variable to search for. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Product does not contain a variable of the specified name. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>, Product contains a variable of the specified name. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv433harp_product_get_variable_by_namePK12harp_productPKcPP13harp_variable">
<span id="_CPPv333harp_product_get_variable_by_namePK12harp_productPKcPP13harp_variable"></span><span id="_CPPv233harp_product_get_variable_by_namePK12harp_productPKcPP13harp_variable"></span><span id="harp_product_get_variable_by_name__harp_productCP.cCP.harp_variablePP"></span><span class="target" id="group__harp__product_1gab79f5cc57e53ecc01e2b83debd423446"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_get_variable_by_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Find variable with a given name for a product. If no variable with the given name can be found an error is returned. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product in which to find the variable. </p></li>
<li><p><strong>name</strong> – Name of the variable. </p></li>
<li><p><strong>variable</strong> – Pointer to the C variable where the found HARP variable will be stored. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv439harp_product_get_variable_index_by_namePK12harp_productPKcPi">
<span id="_CPPv339harp_product_get_variable_index_by_namePK12harp_productPKcPi"></span><span id="_CPPv239harp_product_get_variable_index_by_namePK12harp_productPKcPi"></span><span id="harp_product_get_variable_index_by_name__harp_productCP.cCP.iP"></span><span class="target" id="group__harp__product_1ga954f21b21958d1f316b83d60a8816d4e"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_get_variable_index_by_name</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">index</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Find index of variable with a given name for a product. If no variable with the given name can be found an error is returned. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product in which the find the variable. </p></li>
<li><p><strong>name</strong> – Name of the variable. </p></li>
<li><p><strong>index</strong> – Pointer to the C variable where the index in the HARP variables list for the product is returned. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv421harp_product_is_emptyPK12harp_product">
<span id="_CPPv321harp_product_is_emptyPK12harp_product"></span><span id="_CPPv221harp_product_is_emptyPK12harp_product"></span><span id="harp_product_is_empty__harp_productCP"></span><span class="target" id="group__harp__product_1ga49f593a4807148aebdea48acc9b8e6af"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_is_empty</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Determine whether all variables in a product have at least one element. If at least one variable has 0 elements or if the product has 0 variables the function returns 1, and 0 otherwise. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>product</strong> – Product to check for empty data. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, The product does not contain empty data. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>, The product contains 0 variables or at least one variable has 0 elements. </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv427harp_product_update_historyP12harp_productPKciA_Pc">
<span id="_CPPv327harp_product_update_historyP12harp_productPKciA_Pc"></span><span id="_CPPv227harp_product_update_historyP12harp_productPKciA_Pc"></span><span id="harp_product_update_history__harp_productP.cCP.i.cPA"></span><span class="target" id="group__harp__product_1ga6e574e19c463cf244b60cc4d25710195"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_update_history</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">executable</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">argc</span></span>, <span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">argv</span></span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">]</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Update the history attribute in the product based on the command line parameters. This function will extend the existing product history metadata element with a line containing the current UTC time, the HARP version, and the call that was used to run this program. The command line execution call is constructed based on the <em>argc</em> and <em>argv</em> arguments. The format of the added line is: YYYY-MM-DDThh:mm:ssZ [harp-x.y] args …. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product for which the history metada should be extended. </p></li>
<li><p><strong>executable</strong> – Name of the command line executable (this value is used instead of argv[0]). </p></li>
<li><p><strong>argc</strong> – Variable as passed by main(). </p></li>
<li><p><strong>argv</strong> – Variable as passed by main(). </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv419harp_product_verifyPK12harp_product">
<span id="_CPPv319harp_product_verifyPK12harp_product"></span><span id="_CPPv219harp_product_verifyPK12harp_product"></span><span id="harp_product_verify__harp_productCP"></span><span class="target" id="group__harp__product_1ga84b6effef3e96d88fa623d14015112df"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_verify</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Verify that a product is internally consistent and complies with conventions. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>product</strong> – Product to verify. </p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Product verified successfully. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv418harp_product_printPK12harp_productiiPFiPKczE">
<span id="_CPPv318harp_product_printPK12harp_productiiPFiPKczE"></span><span id="_CPPv218harp_product_printPK12harp_productiiPFiPKczE"></span><span class="target" id="group__harp__product_1gaa19c7763369e3ab99129c7beb6bbedad"></span><span class="kt"><span class="pre">void</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_print</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">show_attributes</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">show_data</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">print</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Print a harp_product struct using the specified print function. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to print. </p></li>
<li><p><strong>show_attributes</strong> – Whether or not to print the attributes of variables. </p></li>
<li><p><strong>show_data</strong> – Whether or not to print the data arrays of the variables </p></li>
<li><p><strong>print</strong> – Print function to use </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv430harp_product_flatten_dimensionP12harp_product19harp_dimension_type">
<span id="_CPPv330harp_product_flatten_dimensionP12harp_product19harp_dimension_type"></span><span id="_CPPv230harp_product_flatten_dimensionP12harp_product19harp_dimension_type"></span><span id="harp_product_flatten_dimension__harp_productP.harp_dimension_type"></span><span class="target" id="group__harp__product_1gaf70331b5522250534866484c23b78500"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_flatten_dimension</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <a class="reference internal" href="libharp_general.html#_CPPv419harp_dimension_type" title="harp_dimension_type"><span class="n"><span class="pre">harp_dimension_type</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">dimension_type</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Collapse a given dimension into the time dimension</p>
<p>Flattening a product for a certain dimension collapses the dimension into the time dimension (i.e. the time dimension and the provided dimension are flattened together). For instance, if a product contains a variable with [num_time,num_longitude,num_latitudes,num_vertical] as dimensions, then flattening for the vertical dimension will result in a variable with [num_time*num_vertical,num_longitudes,num_latitudes] as dimensions.</p>
<p>The end result of this function is that the time dimension will have grown by a factor equal to the length of the given dimension type and that none of the variables in the product will depend on the given dimension type anymore.</p>
<p>Independent dimensions and the time dimension cannot be flattened. In the special case that the length of the flattened dimension equals 1, the dimension is just removed for all variables.</p>
<p>If the dimension length does not equal 1 then the following applies:<ul class="simple">
<li><p>any variables that depend more than once on the given dimension type will be removed from the product,</p></li>
<li><p>the index and collocation_index variables will be removed if present, and</p></li>
<li><p>variables that had the given dimension type but were time independent are first made time dependent</p></li>
</ul>
</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – HARP product. </p></li>
<li><p><strong>dimension_type</strong> – Dimension to use for the flattening. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv417harp_product_sortP12harp_productiPPKc">
<span id="_CPPv317harp_product_sortP12harp_productiPPKc"></span><span id="_CPPv217harp_product_sortP12harp_productiPPKc"></span><span id="harp_product_sort__harp_productP.i.cCPP"></span><span class="target" id="group__harp__product_1gaa8c8de3f047d36f74579b9d8e5decb50"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_sort</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_variables</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable_name</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Reorder a dimension for all variables in a product such that the variables with the given names ends up sorted.</p>
<p>Variables for the provided variable_name list should exist in the product and the variables should be one dimensional variables, all using the same dimension. The dimension that will be reordered is this single dimension of the referenced variables.</p>
<p>Only up to eight variables can be used for sorting.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – HARP product </p></li>
<li><p><strong>num_variables</strong> – Number of variables to use for sorting (1 &lt;= num_variables &lt;= 8) </p></li>
<li><p><strong>variable_name</strong> – Names of the variables to use for sorting </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv431harp_product_execute_operationsP12harp_productPKc">
<span id="_CPPv331harp_product_execute_operationsP12harp_productPKc"></span><span id="_CPPv231harp_product_execute_operationsP12harp_productPKc"></span><span id="harp_product_execute_operations__harp_productP.cCP"></span><span class="target" id="group__harp__product_1gaac9e4b48ca9a060f53c1e2bb4f44d840"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_execute_operations</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">operations</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Execute one or more operations on a product.</p>
<p>if one of the operations results in an empty product then the function will immediately return with the empty product (and return code 0) and will not execute any of the remaining actions anymore. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product that the operations should be executed on. </p></li>
<li><p><strong>operations</strong> – Operations to execute; should be specified as a semi-colon separated string of operations. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv444harp_product_rebin_with_axis_bounds_variableP12harp_productP13harp_variable">
<span id="_CPPv344harp_product_rebin_with_axis_bounds_variableP12harp_productP13harp_variable"></span><span id="_CPPv244harp_product_rebin_with_axis_bounds_variableP12harp_productP13harp_variable"></span><span id="harp_product_rebin_with_axis_bounds_variable__harp_productP.harp_variableP"></span><span class="target" id="group__harp__product_1gafff2379c782c653ac75a743d0df868ca"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_rebin_with_axis_bounds_variable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">target_bounds</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Rebin all variables in the product to a specified interval grid. The target bounds variable should be an axis bounds variable containing the interval edges (bins) of the target grid </p>
<section id="group__harp__product_1autotoc_md0">
<h2>(as ‘double’ values). It should be a two-dimensional variable (for a time independent grid) or a three-dimensional</h2>
</section>
<section id="group__harp__product_1autotoc_md1">
<span id="group__harp__product_1autotoc_md0"></span><h2>variable (for a time dependent grid).</h2>
<p id="group__harp__product_1autotoc_md1">The last dimension should be an independent dimension of length 2 (for the lower/upper bound of each interval). The dimension to use for regridding is based on the type of the second to last dimension of the target grid variable. This function cannot be used to rebin an independent dimension.</p>
<p>For each variable in the product, a dimension-specific rule based on the variable name will determine how to rebin the variable. For most variables the result will be the interval weighted average of all values overlapping the target interval. This weight includes the weight of an existing weight variable (by means of multiplication) if it exists.</p>
<p>Variables that represent an integrated quantity for the rebinned dimension will use an interval weighted sum. For uncertainty variables the first order propagation rules are used (assuming full correlation).</p>
<p>For angle variables a variable-specific weight will be used that contains the magnitude of the sum of the unit vectors that was used to calculate the angle average. This weight is multiplied by any existing weight variable.</p>
<p>Variables that depend on the rebinned dimenion but have no unit (or use a string data type) will be removed. Any existing count variables that depend on the given dimension will also be removed.</p>
<p>All variables that are rebinned (except existing weight variables) are converted to a double data type. Bins that have no overlapping source boundaries will end up with a NaN value.</p>
<p></p>
</section>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to rebin. </p></li>
<li><p><strong>target_bounds</strong> – Target grid boundaries variable.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv438harp_product_regrid_with_axis_variableP12harp_productP13harp_variableP13harp_variable">
<span id="_CPPv338harp_product_regrid_with_axis_variableP12harp_productP13harp_variableP13harp_variable"></span><span id="_CPPv238harp_product_regrid_with_axis_variableP12harp_productP13harp_variableP13harp_variable"></span><span id="harp_product_regrid_with_axis_variable__harp_productP.harp_variableP.harp_variableP"></span><span class="target" id="group__harp__product_1ga07a808c69fa7972af739aad407860ee1"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_regrid_with_axis_variable</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">target_grid</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">target_bounds</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Resample all variables in the product against a specified grid. The target grid variable should be an axis variable containing the target grid (as ‘double’ values). It should be a one-dimensional variable (for a time independent grid or when regridding in the time dimension) or a two-dimensional variable (for a time dependent grid when not regridding in the time dimension). The dimension to use for regridding is based on the type of the last dimenion of the target grid variable. This function cannot be used to regrid an independent dimension.</p>
<p>If the target grid variable is two dimensional then its time dimension should match that of the product.</p>
<p>For each variable in the product a dimension-specific rule based on the variable name will determine how to regrid the variable (point/interval interpolation). If interval interpolation is needed for one of the variables then target boundaries are needed. These can be provided using the optional target_bounds parameter. If this parameter is not provided, the boundaries will be calculated automatically from the target grid (by inter/extrapolating intervals from mid-points).</p>
<p>The source grid (and bounds) are determined by performing a variable derivation on the product (using the variable name of the target_grid variable).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to resample. </p></li>
<li><p><strong>target_grid</strong> – Target grid variable. </p></li>
<li><p><strong>target_bounds</strong> – Target grid boundaries variable (optional).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv443harp_product_regrid_with_collocated_productP12harp_product19harp_dimension_typePKcPKcPK12harp_product">
<span id="_CPPv343harp_product_regrid_with_collocated_productP12harp_product19harp_dimension_typePKcPKcPK12harp_product"></span><span id="_CPPv243harp_product_regrid_with_collocated_productP12harp_product19harp_dimension_typePKcPKcPK12harp_product"></span><span id="harp_product_regrid_with_collocated_product__harp_productP.harp_dimension_type.cCP.cCP.harp_productCP"></span><span class="target" id="group__harp__product_1ga57f043de9059d94f7a4060789f780364"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_regrid_with_collocated_product</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <a class="reference internal" href="libharp_general.html#_CPPv419harp_dimension_type" title="harp_dimension_type"><span class="n"><span class="pre">harp_dimension_type</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">dimension_type</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">axis_name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">axis_unit</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">collocated_product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Regrid the product’s variables to the target grid of the collocated product.</p>
<p>This function cannot be used to regrid the time dimension (or an independent dimension).</p>
<p>Both the product and the collocated product need to have <code class="docutils literal notranslate"><span class="pre">collocation_index</span></code> variables. These collocation indices will be used to determine the matching pairs. For each <code class="docutils literal notranslate"><span class="pre">collocation_index</span></code> value in <em>product</em> there needs to be a matching value in the <code class="docutils literal notranslate"><span class="pre">collocation_index</span></code> variable of <em>collocated_product</em> (but the reverse does not have to be true).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to regrid. </p></li>
<li><p><strong>dimension_type</strong> – Type of dimension that should be regridded. </p></li>
<li><p><strong>axis_name</strong> – The name of the variable to use as target grid. </p></li>
<li><p><strong>axis_unit</strong> – The unit in which the vertical_axis will be brought for the regridding. </p></li>
<li><p><strong>collocated_product</strong> – The product containing the collocated measurements and the target grid for the regridding.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv443harp_product_regrid_with_collocated_datasetP12harp_product19harp_dimension_typePKcPKcP23harp_collocation_result">
<span id="_CPPv343harp_product_regrid_with_collocated_datasetP12harp_product19harp_dimension_typePKcPKcP23harp_collocation_result"></span><span id="_CPPv243harp_product_regrid_with_collocated_datasetP12harp_product19harp_dimension_typePKcPKcP23harp_collocation_result"></span><span id="harp_product_regrid_with_collocated_dataset__harp_productP.harp_dimension_type.cCP.cCP.harp_collocation_resultP"></span><span class="target" id="group__harp__product_1ga47c35b04d92f993a62d9911619fe0ea9"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_regrid_with_collocated_dataset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <a class="reference internal" href="libharp_general.html#_CPPv419harp_dimension_type" title="harp_dimension_type"><span class="n"><span class="pre">harp_dimension_type</span></span></a><span class="w"> </span><span class="n sig-param"><span class="pre">dimension_type</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">axis_name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">axis_unit</span></span>, <a class="reference internal" href="libharp_collocation.html#_CPPv423harp_collocation_result" title="harp_collocation_result"><span class="n"><span class="pre">harp_collocation_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">collocation_result</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Regrid the product’s variables (from dataset a in the collocation result) to the target grid of collocated products in dataset b.</p>
<p>This function cannot be used to regrid the time dimension (or an independent dimension).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to regrid. </p></li>
<li><p><strong>dimension_type</strong> – Type of dimension that should be regridded. </p></li>
<li><p><strong>axis_name</strong> – The name of the variable to use as target grid. </p></li>
<li><p><strong>axis_unit</strong> – The unit in which the vertical_axis will be brought for the regridding. </p></li>
<li><p><strong>collocation_result</strong> – The collocation result used to find matching variables. The collocation result is assumed to have the appropriate metadata available for all matches (dataset b).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv452harp_product_smooth_vertical_with_collocated_productP12harp_productiPPKcPKcPKcPK12harp_product">
<span id="_CPPv352harp_product_smooth_vertical_with_collocated_productP12harp_productiPPKcPKcPKcPK12harp_product"></span><span id="_CPPv252harp_product_smooth_vertical_with_collocated_productP12harp_productiPPKcPKcPKcPK12harp_product"></span><span id="harp_product_smooth_vertical_with_collocated_product__harp_productP.i.cCPP.cCP.cCP.harp_productCP"></span><span class="target" id="group__harp__product_1ga2783850e720160c503036b6f66fbdf3d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_smooth_vertical_with_collocated_product</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_smooth_variables</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">smooth_variables</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_axis</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_unit</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">collocated_product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Smooth the product’s variables using the vertical grids, avks and a apriori of the collocated product.</p>
<p>The product is first fully regridded (using the vertical dimension) to the vertical grid of the averaging kernel (and apriori). Then, the given list of variables is smoothed using the list of AVKs and apriori variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to smooth. </p></li>
<li><p><strong>num_smooth_variables</strong> – length of smooth_variables. </p></li>
<li><p><strong>smooth_variables</strong> – The names of the variables to smooth. </p></li>
<li><p><strong>vertical_axis</strong> – The name of the variable to use as a vertical axis (pressure/altitude/etc). </p></li>
<li><p><strong>vertical_unit</strong> – The unit in which the vertical_axis will be brought for the regridding. </p></li>
<li><p><strong>collocated_product</strong> – The product containing the collocated measurements and the averaging kernel and a-priori.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv452harp_product_smooth_vertical_with_collocated_datasetP12harp_productiPPKcPKcPKcPK23harp_collocation_result">
<span id="_CPPv352harp_product_smooth_vertical_with_collocated_datasetP12harp_productiPPKcPKcPKcPK23harp_collocation_result"></span><span id="_CPPv252harp_product_smooth_vertical_with_collocated_datasetP12harp_productiPPKcPKcPKcPK23harp_collocation_result"></span><span id="harp_product_smooth_vertical_with_collocated_dataset__harp_productP.i.cCPP.cCP.cCP.harp_collocation_resultCP"></span><span class="target" id="group__harp__product_1ga615f50993415eea52aea0ef0f1743374"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_smooth_vertical_with_collocated_dataset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_smooth_variables</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">smooth_variables</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_axis</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_unit</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="libharp_collocation.html#_CPPv423harp_collocation_result" title="harp_collocation_result"><span class="n"><span class="pre">harp_collocation_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">collocation_result</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Smooth the product’s variables (from dataset a in the collocation result) using the vertical grids, avks and a apriori of collocated products in dataset b.</p>
<p>The product is first fully regridded (using the vertical dimension) to the vertical grid of the averaging kernel (and apriori). Then, the given list of variables is smoothed using the list of AVKs and apriori variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to smooth. </p></li>
<li><p><strong>num_smooth_variables</strong> – length of smooth_variables. </p></li>
<li><p><strong>smooth_variables</strong> – The names of the variables to smooth. </p></li>
<li><p><strong>vertical_axis</strong> – The name of the variable to use as a vertical axis (pressure/altitude/etc). </p></li>
<li><p><strong>vertical_unit</strong> – The unit in which the vertical_axis will be brought for the regridding. </p></li>
<li><p><strong>collocation_result</strong> – The collocation result used to locate the matching vertical grids/avks/apriori. The collocation result is assumed to have the appropriate metadata available for all matches (dataset b).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv432harp_product_get_smoothed_columnP12harp_productPKcPKcP13harp_variableP13harp_variableP13harp_variableP13harp_variablePP13harp_variable">
<span id="_CPPv332harp_product_get_smoothed_columnP12harp_productPKcPKcP13harp_variableP13harp_variableP13harp_variableP13harp_variablePP13harp_variable"></span><span id="_CPPv232harp_product_get_smoothed_columnP12harp_productPKcPKcP13harp_variableP13harp_variableP13harp_variableP13harp_variablePP13harp_variable"></span><span id="harp_product_get_smoothed_column__harp_productP.cCP.cCP.harp_variableP.harp_variableP.harp_variableP.harp_variableP.harp_variablePP"></span><span class="target" id="group__harp__product_1ga63186eb4d5508d85d8f2d332245871f1"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_get_smoothed_column</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">unit</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_grid</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_bounds</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">column_avk</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">apriori</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Derive vertical column smoothed with column averaging kernel and optional a-priori First a partial column profile will be derived from the product. This partial column profile will be regridded to the column averaging kernel grid. The regridded column profile will then be combined with the column averaging kernel and optional apriori profile to create an integrated smoothed vertical column. All inputs need to be provided as ‘double’ data. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product from which to derive a smoothed integrated vertical column. </p></li>
<li><p><strong>name</strong> – Name of the variable that should be created. </p></li>
<li><p><strong>unit</strong> – Unit (optional) of the variable that should be created. </p></li>
<li><p><strong>vertical_grid</strong> – Variable containing the vertical grid of the column avk. </p></li>
<li><p><strong>vertical_bounds</strong> – Variable containing the grid boundaries of the column avk (optional). </p></li>
<li><p><strong>column_avk</strong> – Column averaging kernel variable. </p></li>
<li><p><strong>apriori</strong> – Apriori profile (optional). </p></li>
<li><p><strong>variable</strong> – Pointer to the C variable where the derived HARP variable will be stored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv457harp_product_get_smoothed_column_using_collocated_productP12harp_productPKcPKciPK19harp_dimension_typePKcPKcPK12harp_productPP13harp_variable">
<span id="_CPPv357harp_product_get_smoothed_column_using_collocated_productP12harp_productPKcPKciPK19harp_dimension_typePKcPKcPK12harp_productPP13harp_variable"></span><span id="_CPPv257harp_product_get_smoothed_column_using_collocated_productP12harp_productPKcPKciPK19harp_dimension_typePKcPKcPK12harp_productPP13harp_variable"></span><span id="harp_product_get_smoothed_column_using_collocated_product__harp_productP.cCP.cCP.i.harp_dimension_typeCP.cCP.cCP.harp_productCP.harp_variablePP"></span><span class="target" id="group__harp__product_1gac2af6aea04439393cfdea79dcb5b528b"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_get_smoothed_column_using_collocated_product</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">unit</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_dimensions</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="libharp_general.html#_CPPv419harp_dimension_type" title="harp_dimension_type"><span class="n"><span class="pre">harp_dimension_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dimension_type</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_axis</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_unit</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">collocated_product</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Derive a vertical column smoothed with column averaging kernel and a-priori from the collocated product</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to regrid. </p></li>
<li><p><strong>name</strong> – Name of the variable that should be created. </p></li>
<li><p><strong>unit</strong> – Unit (optional) of the variable that should be created. </p></li>
<li><p><strong>num_dimensions</strong> – Number of dimensions of the variable that should be created. </p></li>
<li><p><strong>dimension_type</strong> – Type of dimension for each of the dimensions of the variable that should be created. </p></li>
<li><p><strong>vertical_axis</strong> – The name of the variable to use as a vertical axis (pressure/altitude/etc). </p></li>
<li><p><strong>vertical_unit</strong> – The unit in which the vertical_axis will be brought for the regridding. </p></li>
<li><p><strong>collocated_product</strong> – The product containing the collocated measurements and the averaging kernel and a-priori. </p></li>
<li><p><strong>variable</strong> – Pointer to the C variable where the derived HARP variable will be stored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv457harp_product_get_smoothed_column_using_collocated_datasetP12harp_productPKcPKciPK19harp_dimension_typePKcPKcPK23harp_collocation_resultPP13harp_variable">
<span id="_CPPv357harp_product_get_smoothed_column_using_collocated_datasetP12harp_productPKcPKciPK19harp_dimension_typePKcPKcPK23harp_collocation_resultPP13harp_variable"></span><span id="_CPPv257harp_product_get_smoothed_column_using_collocated_datasetP12harp_productPKcPKciPK19harp_dimension_typePKcPKcPK23harp_collocation_resultPP13harp_variable"></span><span id="harp_product_get_smoothed_column_using_collocated_dataset__harp_productP.cCP.cCP.i.harp_dimension_typeCP.cCP.cCP.harp_collocation_resultCP.harp_variablePP"></span><span class="target" id="group__harp__product_1gaa1910631a41729975dffe7a2dda8aa33"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_get_smoothed_column_using_collocated_dataset</span></span></span><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">name</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">unit</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="n sig-param"><span class="pre">num_dimensions</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="libharp_general.html#_CPPv419harp_dimension_type" title="harp_dimension_type"><span class="n"><span class="pre">harp_dimension_type</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">dimension_type</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_axis</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">vertical_unit</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="libharp_collocation.html#_CPPv423harp_collocation_result" title="harp_collocation_result"><span class="n"><span class="pre">harp_collocation_result</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">collocation_result</span></span>, <a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">variable</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Derive a vertical column smoothed with column averaging kernel and a-priori from collocated products in dataset b</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>product</strong> – Product to regrid. </p></li>
<li><p><strong>name</strong> – Name of the variable that should be created. </p></li>
<li><p><strong>unit</strong> – Unit (optional) of the variable that should be created. </p></li>
<li><p><strong>num_dimensions</strong> – Number of dimensions of the variable that should be created. </p></li>
<li><p><strong>dimension_type</strong> – Type of dimension for each of the dimensions of the variable that should be created. </p></li>
<li><p><strong>vertical_axis</strong> – The name of the variable to use as a vertical axis (pressure/altitude/etc). </p></li>
<li><p><strong>vertical_unit</strong> – The unit in which the vertical_axis will be brought for the regridding. </p></li>
<li><p><strong>collocation_result</strong> – The collocation result used to find matching variables. The collocation result is assumed to have the appropriate metadata available for all matches (dataset b). </p></li>
<li><p><strong>variable</strong> – Pointer to the C variable where the derived HARP variable will be stored.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411harp_importPKcPKcPKcPP12harp_product">
<span id="_CPPv311harp_importPKcPKcPKcPP12harp_product"></span><span id="_CPPv211harp_importPKcPKcPKcPP12harp_product"></span><span id="harp_import__cCP.cCP.cCP.harp_productPP"></span><span class="target" id="group__harp__product_1gad34fd0e7ec4e7f9e7f796aa7344f4b24"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_import</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filename</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">operations</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">options</span></span>, <a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Import a product from a file.</p>
<p>This will first try to import the file as an HDF4, HDF5, or netCDF file that complies to the HARP Data Format. If the file is not stored using the HARP format then it will try to import it using one of the available ingestion modules. The <em>options</em> parameter is optional (can be NULL) and describes the ingestion options. The parameter is only applicable if the file is not already using the HARP format and needs to be converted using one of the ingestion modules. The <em>operations</em> parameter is optional (can be NULL) and provides the list of operations that will be performed as part of the import. Some operations, such as filters, can already be performed as part of an import and this may thus be faster than using a <a class="reference internal" href="#group__harp__product_1gaac9e4b48ca9a060f53c1e2bb4f44d840"><span class="std std-ref">harp_product_execute_operations()</span></a> after a full import of the product. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> – <strong>[in]</strong> Path to the file that is to be imported. </p></li>
<li><p><strong>operations</strong> – <strong>[in]</strong> string (optional) containing actions to apply as part of the import; should be specified as a semi-colon separated string of operations. </p></li>
<li><p><strong>options</strong> – <strong>[in]</strong> Ingestion module specific options (optional); should be specified as a semi-colon separated string of key=value pair; only used if the file is not in HARP format. </p></li>
<li><p><strong>product</strong> – <strong>[out]</strong> Pointer to a location where a pointer to the ingested product will be stored. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv416harp_import_testPKcPFiPKczE">
<span id="_CPPv316harp_import_testPKcPFiPKczE"></span><span id="_CPPv216harp_import_testPKcPFiPKczE"></span><span class="target" id="group__harp__product_1ga0b4ebfc36043501d174e6c5176698274"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_import_test</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filename</span></span>, <span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="p"><span class="pre">(</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">print</span></span><span class="p"><span class="pre">)</span></span><span class="p"><span class="pre">(</span></span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="p"><span class="pre">...</span></span><span class="p"><span class="pre">)</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Test import of a product.</p>
<p>If the product is a HARP product then verify that the product is a HARP compliant netCDF/HDF4/HDF5 product. Otherwise, try to import the product using an applicable ingestion module and test the ingestion for all possible ingestion options. Results are printed using the provided <em>print</em> function. The <em>print</em> function parameter should be a function that resembles printf(). </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> – <strong>[in]</strong> Filename of the product to import. </p></li>
<li><p><strong>print</strong> – <strong>[in]</strong> Reference to a printf compatible function. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">1</span></code>, Import failed (error is already printed, <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a> should be ignored). </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv428harp_import_product_metadataPKcPKcPP21harp_product_metadata">
<span id="_CPPv328harp_import_product_metadataPKcPKcPP21harp_product_metadata"></span><span id="_CPPv228harp_import_product_metadataPKcPKcPP21harp_product_metadata"></span><span id="harp_import_product_metadata__cCP.cCP.harp_product_metadataPP"></span><span class="target" id="group__harp__product_1ga596533e3a82733332a90f6b1850f21f3"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_import_product_metadata</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filename</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">options</span></span>, <a class="reference internal" href="libharp_product_metadata.html#_CPPv421harp_product_metadata" title="harp_product_metadata"><span class="n"><span class="pre">harp_product_metadata</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">new_metadata</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Retrieve global attributes from a product file.</p>
<p>This function retrieves the product metadata without performing a full import. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> – Path to the file for which to retrieve global attributes. </p></li>
<li><p><strong>options</strong> – Ingestion module specific options (optional); should be specified as a semi-colon separated string of key=value pair; only used if the file is not in HARP format. </p></li>
<li><p><strong>new_metadata</strong> – Pointer to the variable where the metadata should be stored. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="cpp function">
<dt class="sig sig-object cpp" id="_CPPv411harp_exportPKcPKcPK12harp_product">
<span id="_CPPv311harp_exportPKcPKcPK12harp_product"></span><span id="_CPPv211harp_exportPKcPKcPK12harp_product"></span><span id="harp_export__cCP.cCP.harp_productCP"></span><span class="target" id="group__harp__product_1ga4baa27278b9ed26482b7dde2d0b390b4"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_export</span></span></span><span class="sig-paren">(</span><span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">filename</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">export_format</span></span>, <span class="k"><span class="pre">const</span></span><span class="w"> </span><a class="reference internal" href="#_CPPv412harp_product" title="harp_product"><span class="n"><span class="pre">harp_product</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="n sig-param"><span class="pre">product</span></span><span class="sig-paren">)</span><br /></dt>
<dd><p>Export HARP product to a file.</p>
<p>Export product to an HDF4, HDF5, or netCDF file that complies to the HARP Data Format. </p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> – Path to the file to which the product is to be exported. </p></li>
<li><p><strong>export_format</strong> – Either “hdf4”, “hdf5”, or “netcdf”. </p></li>
<li><p><strong>product</strong> – Product that should be exported to file. </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">0</span></code>, Success. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">-1</span></code>, Error occurred (check <a class="reference internal" href="libharp_error.html#group__harp__error_1gab2eeb46528306c6799632d1e800c4c36"><span class="std std-ref">harp_errno</span></a>). </p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

</div>
<dl class="cpp struct">
<dt class="sig sig-object cpp" id="_CPPv419harp_product_struct">
<span id="_CPPv319harp_product_struct"></span><span id="_CPPv219harp_product_struct"></span><span id="harp_product_struct"></span><span class="target" id="structharp__product__struct"></span><span class="k"><span class="pre">struct</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">harp_product_struct</span></span></span><br /></dt>
<dd><div class="docutils container">
<em>#include &lt;harp.h&gt;</em></div>
<p>HARP Product struct </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric" id="breathe-section-title-public-members">Public Members</p>
<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19harp_product_struct9dimensionE">
<span id="_CPPv3N19harp_product_struct9dimensionE"></span><span id="_CPPv2N19harp_product_struct9dimensionE"></span><span id="harp_product_struct::dimension__lA"></span><span class="target" id="structharp__product__struct_1a2b479dd242dcc077c95ebb3736cf594a"></span><span class="kt"><span class="pre">long</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">dimension</span></span></span><span class="p"><span class="pre">[</span></span><span class="n"><span class="pre">HARP_NUM_DIM_TYPES</span></span><span class="p"><span class="pre">]</span></span><br /></dt>
<dd><p>length of each dimension (0 for unused dimensions) </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19harp_product_struct13num_variablesE">
<span id="_CPPv3N19harp_product_struct13num_variablesE"></span><span id="_CPPv2N19harp_product_struct13num_variablesE"></span><span id="harp_product_struct::num_variables__i"></span><span class="target" id="structharp__product__struct_1a2ba7d62da65ff95eae9aa4c64e05fe5d"></span><span class="kt"><span class="pre">int</span></span><span class="w"> </span><span class="sig-name descname"><span class="n"><span class="pre">num_variables</span></span></span><br /></dt>
<dd><p>number of variables in this product </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19harp_product_struct8variableE">
<span id="_CPPv3N19harp_product_struct8variableE"></span><span id="_CPPv2N19harp_product_struct8variableE"></span><span id="harp_product_struct::variable__harp_variablePP"></span><span class="target" id="structharp__product__struct_1a1f5ae397c76bc98f5b3d0a8f83df2bef"></span><a class="reference internal" href="libharp_variable.html#_CPPv413harp_variable" title="harp_variable"><span class="n"><span class="pre">harp_variable</span></span></a><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">variable</span></span></span><br /></dt>
<dd><p>pointers to the variables </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19harp_product_struct14source_productE">
<span id="_CPPv3N19harp_product_struct14source_productE"></span><span id="_CPPv2N19harp_product_struct14source_productE"></span><span id="harp_product_struct::source_product__cP"></span><span class="target" id="structharp__product__struct_1ac4188bb9f4fc3b0a70418ba4f67ff8dd"></span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">source_product</span></span></span><br /></dt>
<dd><p>identifier of the product the HARP product originates from </p>
</dd></dl>

<dl class="cpp var">
<dt class="sig sig-object cpp" id="_CPPv4N19harp_product_struct7historyE">
<span id="_CPPv3N19harp_product_struct7historyE"></span><span id="_CPPv2N19harp_product_struct7historyE"></span><span id="harp_product_struct::history__cP"></span><span class="target" id="structharp__product__struct_1a20a905e5529c6aa145a1eadfb556903b"></span><span class="kt"><span class="pre">char</span></span><span class="w"> </span><span class="p"><span class="pre">*</span></span><span class="sig-name descname"><span class="n"><span class="pre">history</span></span></span><br /></dt>
<dd><p>value for the ‘history’ global attribute </p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="libharp_geometry.html" class="btn btn-neutral float-left" title="Geometry" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="libharp_product_metadata.html" class="btn btn-neutral float-right" title="Product Metadata" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025 S[&amp;]T, The Netherlands.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>